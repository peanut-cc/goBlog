// Code generated by entc, DO NOT EDIT.

package ent

import (
	"fmt"
	"strings"

	"github.com/facebook/ent/dialect/sql"
	"github.com/peanut-cc/goBlog/internal/app/ent/blog"
)

// Blog is the model entity for the Blog schema.
type Blog struct {
	config `json:"-"`
	// ID of the ent.
	ID int `json:"id,omitempty"`
	// DefaultPageNum holds the value of the "default_page_num" field.
	DefaultPageNum int `json:"default_page_num,omitempty"`
	// BlogName holds the value of the "blog_name" field.
	BlogName string `json:"blog_name,omitempty"`
	// Btitle holds the value of the "btitle" field.
	Btitle string `json:"btitle,omitempty"`
	// Subtitle holds the value of the "subtitle" field.
	Subtitle string `json:"subtitle,omitempty"`
	// Beian holds the value of the "beian" field.
	Beian string `json:"beian,omitempty"`
	// CopyRight holds the value of the "copy_right" field.
	CopyRight string `json:"copy_right,omitempty"`
}

// scanValues returns the types for scanning values from sql.Rows.
func (*Blog) scanValues() []interface{} {
	return []interface{}{
		&sql.NullInt64{},  // id
		&sql.NullInt64{},  // default_page_num
		&sql.NullString{}, // blog_name
		&sql.NullString{}, // btitle
		&sql.NullString{}, // subtitle
		&sql.NullString{}, // beian
		&sql.NullString{}, // copy_right
	}
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the Blog fields.
func (b *Blog) assignValues(values ...interface{}) error {
	if m, n := len(values), len(blog.Columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	value, ok := values[0].(*sql.NullInt64)
	if !ok {
		return fmt.Errorf("unexpected type %T for field id", value)
	}
	b.ID = int(value.Int64)
	values = values[1:]
	if value, ok := values[0].(*sql.NullInt64); !ok {
		return fmt.Errorf("unexpected type %T for field default_page_num", values[0])
	} else if value.Valid {
		b.DefaultPageNum = int(value.Int64)
	}
	if value, ok := values[1].(*sql.NullString); !ok {
		return fmt.Errorf("unexpected type %T for field blog_name", values[1])
	} else if value.Valid {
		b.BlogName = value.String
	}
	if value, ok := values[2].(*sql.NullString); !ok {
		return fmt.Errorf("unexpected type %T for field btitle", values[2])
	} else if value.Valid {
		b.Btitle = value.String
	}
	if value, ok := values[3].(*sql.NullString); !ok {
		return fmt.Errorf("unexpected type %T for field subtitle", values[3])
	} else if value.Valid {
		b.Subtitle = value.String
	}
	if value, ok := values[4].(*sql.NullString); !ok {
		return fmt.Errorf("unexpected type %T for field beian", values[4])
	} else if value.Valid {
		b.Beian = value.String
	}
	if value, ok := values[5].(*sql.NullString); !ok {
		return fmt.Errorf("unexpected type %T for field copy_right", values[5])
	} else if value.Valid {
		b.CopyRight = value.String
	}
	return nil
}

// Update returns a builder for updating this Blog.
// Note that, you need to call Blog.Unwrap() before calling this method, if this Blog
// was returned from a transaction, and the transaction was committed or rolled back.
func (b *Blog) Update() *BlogUpdateOne {
	return (&BlogClient{config: b.config}).UpdateOne(b)
}

// Unwrap unwraps the entity that was returned from a transaction after it was closed,
// so that all next queries will be executed through the driver which created the transaction.
func (b *Blog) Unwrap() *Blog {
	tx, ok := b.config.driver.(*txDriver)
	if !ok {
		panic("ent: Blog is not a transactional entity")
	}
	b.config.driver = tx.drv
	return b
}

// String implements the fmt.Stringer.
func (b *Blog) String() string {
	var builder strings.Builder
	builder.WriteString("Blog(")
	builder.WriteString(fmt.Sprintf("id=%v", b.ID))
	builder.WriteString(", default_page_num=")
	builder.WriteString(fmt.Sprintf("%v", b.DefaultPageNum))
	builder.WriteString(", blog_name=")
	builder.WriteString(b.BlogName)
	builder.WriteString(", btitle=")
	builder.WriteString(b.Btitle)
	builder.WriteString(", subtitle=")
	builder.WriteString(b.Subtitle)
	builder.WriteString(", beian=")
	builder.WriteString(b.Beian)
	builder.WriteString(", copy_right=")
	builder.WriteString(b.CopyRight)
	builder.WriteByte(')')
	return builder.String()
}

// Blogs is a parsable slice of Blog.
type Blogs []*Blog

func (b Blogs) config(cfg config) {
	for _i := range b {
		b[_i].config = cfg
	}
}
